package dao;

import static dao.DAOUtilities.closeAll;
import static dao.DAOUtilities.initPreparedStatement;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;

import beans.Bean;
import beans.Candidate;

public class CandidateDAO extends ObjectDAO {
	
	public CandidateDAO(DAOFactory daoFactory) {
		super(daoFactory);
	}
	
	public List<Candidate> candidatesOfDay() {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		List<Candidate> candidates = new ArrayList<>();
		
		try {
			connection = daoFactory.getConnection();
			preparedStatement = initPreparedStatement(connection, "SELECT * FROM candidates "
					+ "WHERE date(updateDate) = CURDATE()", false);
			resultSet = preparedStatement.executeQuery();
			while (resultSet.next()) {
				candidates.add(map(resultSet));
	        }
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(resultSet, preparedStatement, connection);
		}
		
		return candidates;
	}
	
	public List<Candidate> applySendDate(List<Candidate> candidates) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		
		try {
			connection = daoFactory.getConnection();
			for (Candidate candidate : candidates) {
				candidate.setSendDate(LocalDateTime.now());
				
				preparedStatement = initPreparedStatement(connection, 
						"UPDATE candidates SET sendDate=NOW() WHERE id=?", false, 
						candidate.getId()
				);
				
				int status = preparedStatement.executeUpdate();
				if (status == 0) {
		            throw new DAOException("Fail to update sendDate candidate");
		        }
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(resultSet, preparedStatement, connection);
		}
		
		return candidates;
	}
	
	public List<Candidate> readAll() {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		List<Candidate> list = new ArrayList<>();
		
		try {
			connection = daoFactory.getConnection();
			preparedStatement = initPreparedStatement(connection, "SELECT * FROM candidates", false);
			resultSet = preparedStatement.executeQuery();
			while (resultSet.next()) {
				list.add(map(resultSet));
	        }
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(resultSet, preparedStatement, connection);
		}
		
		return list;
	}

	@Override
	public void create(Bean bean) throws DAOException {
		Candidate candidate = (Candidate) bean;
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet autoGeneratedValues = null;
		
		try {
			connection = daoFactory.getConnection();
			preparedStatement = initPreparedStatement(connection, 
					"INSERT INTO candidates (title, lastName, firstName, email, livesAt, street, numStreet, "
					+ "postCode, locality, country, requestDate, insertDate, updateDate, sendDate, "
					+ "initials, jobFunction, answer, folder) "
					+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), ?, ?, ?, ?, ?)", true, 
					candidate.getTitle(), 
					candidate.getLastName(), 
					candidate.getFirstName(),
					candidate.getEmail(),
					candidate.getLivesAt(),
					candidate.getStreet(),
					candidate.getNumStreet(),
					candidate.getPostCode(),
					candidate.getLocality(),
					candidate.getCountry(),
					candidate.getRequestDateSQLFormatted(),
					// datetime -> NOW()
					candidate.getSendDateSQLFormatted(),
					candidate.getInitials(),
					candidate.getJobFunction(),
					candidate.getAnswer(),
					candidate.getFolder()
			);
			
			int status = preparedStatement.executeUpdate();
			if (status == 0) {
	            throw new DAOException("Fail to create new candidate");
	        }
			
			autoGeneratedValues = preparedStatement.getGeneratedKeys();
			if (autoGeneratedValues.next()) {
				candidate.setId(autoGeneratedValues.getLong(1));
			} else {
				throw new DAOException("Fail to create candidate, no auto generated id returned");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(autoGeneratedValues, preparedStatement, connection);
		}
	}
	
	@Override
	public Candidate read(Long id) throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Candidate candidate = null;
		
		try {
			connection = daoFactory.getConnection();
			preparedStatement = initPreparedStatement(connection, "SELECT * FROM candidates WHERE id = ?", false, id);
			resultSet = preparedStatement.executeQuery();
			if (resultSet.next()) {
	            candidate = map(resultSet);
	        }
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(resultSet, preparedStatement, connection);
		}
		
		return candidate;
	}
	
	@Override
	public void update(Bean bean) throws DAOException {
		Candidate candidate = (Candidate) bean;
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet autoGeneratedValues = null;
		
		try {
			connection = daoFactory.getConnection();
			preparedStatement = initPreparedStatement(connection, 
					"UPDATE candidates SET title=?, lastName=?, firstName=?, email=?, livesAt=?, street=?, numStreet=?, "
					+ "postCode=?, locality=?, country=?, requestDate=?, updateDate=NOW(), "
					+ "initials=?, jobFunction=?, answer=?, folder=? "
					+ "WHERE id=?", true, 
					candidate.getTitle(), 
					candidate.getLastName(), 
					candidate.getFirstName(),
					candidate.getEmail(),
					candidate.getLivesAt(),
					candidate.getStreet(),
					candidate.getNumStreet(),
					candidate.getPostCode(),
					candidate.getLocality(),
					candidate.getCountry(),
					candidate.getRequestDateSQLFormatted(),
					candidate.getInitials(),
					candidate.getJobFunction(),
					candidate.getAnswer(),
					candidate.getFolder(),
					candidate.getId()
			);
			
			int status = preparedStatement.executeUpdate();
			if (status == 0) {
	            throw new DAOException("Fail to update candidate");
	        }
			
			autoGeneratedValues = preparedStatement.getGeneratedKeys();
			if (autoGeneratedValues.next()) {
				candidate.setId(autoGeneratedValues.getLong(1));
			} else {
				throw new DAOException("Fail to update candidate, no auto generated id returned");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			closeAll(autoGeneratedValues, preparedStatement, connection);
		}
	}

	@Override
	public void delete(Bean bean) throws DAOException {
		// TODO Auto-generated method stub
	}
	
	private static LocalDate parseLocalDate(String str) {
		if (str == null || str.isEmpty()) {
			return null;
		}
		return LocalDate.parse(str);
	}
	
	private static LocalDateTime parseLocalDateTime(String str, DateTimeFormatter formatter) {
		if (str == null || str.isEmpty()) {
			return null;
		}
		return LocalDateTime.parse(str, formatter);
	}
	
	private static Candidate map(ResultSet r) throws SQLException {		
		DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss.S");
		
	    return new Candidate(r.getLong(idField), r.getString("title"), r.getString("lastName"), 
	    		r.getString("firstName"), r.getString("email"), r.getString("livesAt"), 
	    		r.getString("street"), r.getString("numStreet"), r.getString("postCode"), 
	    		r.getString("locality"), r.getString("country"),
	    		parseLocalDate(r.getString("requestDate")),
	    		parseLocalDateTime(r.getString("insertDate"), formatter),
	    		parseLocalDateTime(r.getString("updateDate"), formatter),
	    		parseLocalDateTime(r.getString("sendDate"), formatter),
	    		r.getString("initials"), r.getString("jobFunction"),
	    		r.getString("answer"), r.getString("folder"));
	}
}